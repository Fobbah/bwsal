#summary Ideas for new BWSAL functionality

Ideas for new BWSAL functionality, in no particular order

= Threat Manager =
Will create a virtual "heatmap" of danger it will encounter if it moves to that position. Can be used to route units through the path with minimum danger. Takes into account tech levels. For example, a Dark Templar will have 0 threat against Zerg where the Overlords cannot see. Against Protoss it will generally have a small baselevel threat due to the possibility of hidden enemy Observers. Dropships will route themselves through areas where they cannot be seen (edge of map, elevated unaccessible territory, etc). Dragoons will prefer to maneuver with an Observor to negate the threat of mines. A full microing solution will have to take into account temporal elements, so this is just a stand-in or foundation for a better solution.

= Force Manager =

Not a controller.

A simple manager that can implement basic AI functionality for attacking. A force manager can be used to determine what groups a player's or enemy's units consist of, and can choose a strategy of where to position the player's units. We can use it currently to assign ScoutManager the positions it needs to scout and when. We can also use it to assign DefenseManager a new chokepoint to defend in the case that an expansions is made or lost. This way we can move strategic logic out of ScoutManager (and I would say DefenseManager, but it doesn't even have that =) to pave the way towards fixing it. Later we can split it up into a more complex array of managers, but for now we can use it to implement basic defend, retreat, or later, attack functionality.

= Scout Manager =

Improve the scout manager so that it tries to stay alive as long as possible inside the enemy base once it finds the enemy base

Might be possible to split the scout manager into 3 overall tasks or goals:

1) Scout empty base locations to check for new enemy bases

2) Scout enemy bases for tech buildings and production capabilities

3) Scout enemy army for size, unit composition, and position

The first two tasks usually occur at specific points in time (i.e. scout on frame X to see if a Spire or Hydralisk Den was constructed) and might be possible to plan in advance, while the third task is more of a continuous process that starts as soon as the first military unit is created.

The Scout Manager does not determine how important each of these tasks are, or how much units to use. Rather the AI tells the scout manager this information. The role of the scout manager is to scout based on the importance levels (i.e. find the best way to enter and scout the enemy base, given the units it has).

= Evasion Tool =

Primary usage: To be used by scouting manager to keep scouting unit(s) alive.

Inputs: Friendly unit to control, set of enemy units to evade.

To keep the initial implementation simple, we can assume enemy units all move at the same speed and move at the speed of the friendly unit.

Output: Set of tile positions, any of which will let the unit survive as long as possible, assuming perfect chase behavior by enemy units. AI can then pick which tile to order the evading unit to move to.

Algorithm:
Two simultaneous breadth-first searches - one starting from friendly unit (call this search BFS1) and one starting from all enemy units (call it BFS2) (just insert the tile position of each enemy unit into heap). Expand each BFS at same movement speed so tiles X tiles from friendly unit in BFS1 are considered at the same time as tiles X tiles from enemy units in BFS2.

If a tile in BFS1 has already been reached by BFS2, don't expand it (handle it as an unwalkable tile or something). This tile can be reached by the enemy first so the evading unit cannot consider it as a possibility.

Let A = Tiles reached by BFS1. Let B = tiles reached by BFS2. Once A - B = 0, backstep 1 iteration to consider the last tiles reached by BFS1 but not BFS2.

Return this set of tiles.

= Chase Tool =

Primary usage: For killing enemy scouting units.

Inputs: Friendly units to control, enemy unit to chase.

To keep the initial implementation simple, we can assume all friendly units all move at the same speed and move at the speed of the enemy unit.

Output: A tile position for each friendly unit that is adjacent to the unit's current location which will move units in correct direction for chase/containment of enemy unit.

Algorithm:
Not sure how best to approach this problem. 1 possible solution is to consider all possible adjacent tiles for each friendly unit (9^n cases), and run the evasion algorithm for each case, then pick the case that results in the minimum life-span of enemy unit.

= Expected Damage Calculator =
Compute expected average damage the enemy can inflict per frame on each tile. Update incrementally so the game doesn't slot to a crawl.

= Risk Adverse Path Planner =

Given set of fixed-location enemy units, start location A, goal location B, Plan path from A to B using A{{{*}}}. Give extra cost to tiles in range of enemy units based on data from the Expected Damage Calculator.

= Other Ideas =

  * Improve the Supply Manager so it uses a more precise algorithm (currently just uses a simple heuristic)
  * Attack Manager - attack stuff, maybe break down into smaller managers
  * Contain Manager - contains the enemy with siege tanks, lurkers, etc.
  * Repair Manager - repair units that are damaged
  * Threat Assessment Manager - Assign a priority to units that are attacking our base.
  * Transport Manager - transports units to a given position, perhaps with a priority, using the risk adverse path planner to find safest paths

  * Add a function to the building placer which takes a choke point and list of building unit types (possibly with repetitions) and returns a list of unit type - build position pairs that can be used to block off the choke point.